import React from 'react';
import { Table, Typography, Card } from 'antd';

const { Title } = Typography;

const LTMfieldsToCompare = [
  'config_captured_at',
  'location',
  'vip',
  'pool_name',
  'irules',
  'monitor',
  'profiles',
  'persistance_profile_name',
  'intermediate_crt',
  'cipher_mapped',
  'bundle_crt',
  'security_logging_profiles'
];

const ASMfieldsToCompare = [
  'config_captured_at',
  'location',
  'vip',
  'pool_name',
  'irules',
  'host_header_data_groupt',
  'host_header_values',
  'persistance_profile_name',
  'security_logging_profiles'
];

// Keeps indentation and formats multiline objects into lines
function resolveValue(val) {
  if (val === null || val === undefined) return ['-'];
  if (typeof val === 'object') {
    if (Array.isArray(val)) {
      return val.flatMap(v => resolveValue(v));
    }
    if (val.data) {
      return val.data.flatMap(line => line.split('\n'));
    }
    if (val.value) return [val.value];
    return [JSON.stringify(val)];
  }
  return val.toString().split('\n');
}

// Creates rows for each line of config
function expandRowData(rowdata, fqdnKeys) {
  const maxLines = Math.max(
    ...fqdnKeys.map(fqdn => {
      const val = rowdata[fqdn];
      return Array.isArray(val) ? val.length : 1;
    })
  );

  const rows = [];

  for (let i = 0; i < maxLines; i++) {
    const row = { field: `${rowdata.field} - Line ${i + 1}` };
    fqdnKeys.forEach(fqdn => {
      const val = rowdata[fqdn];
      if (Array.isArray(val)) {
        row[fqdn] = val[i] ?? '';
      } else {
        row[fqdn] = i === 0 ? val : '';
      }
    });
    rows.push(row);
  }

  return rows;
}

const TransposedFqdnGrouped = ({ selectedVal, data }) => {
  if (!data || data.length === 0) return <p>No data to display.</p>;

  const isLTM = selectedVal === 'LTM';
  const fieldsToCompare = isLTM ? LTMfieldsToCompare : ASMfieldsToCompare;

  const filteredDevices = data.filter(d => d.device_type === selectedVal);
  const fqdnKeys = filteredDevices.map(item => item.device_name);

  function df(rowdata, titleSuffix = '') {
    const columns = [
      {
        title: 'Field',
        dataIndex: 'field',
        fixed: 'left',
        width: 250,
        render: text => <pre style={{ margin: 0 }}>{text}</pre>
      },
      ...fqdnKeys.map(fqdn => ({
        title: fqdn,
        dataIndex: fqdn,
        render: val => (
          <pre style={{ margin: 0, whiteSpace: 'pre-wrap' }}>
            {val || ''}
          </pre>
        )
      }))
    ];

    const expanded = expandRowData(rowdata, fqdnKeys);

    return (
      <Card key={`${rowdata.field}-${titleSuffix}`} bordered>
        <Title level={4} style={{ textTransform: 'uppercase' }}>
          {selectedVal} - {rowdata.field} {titleSuffix ? `: ${titleSuffix}` : ''}
        </Title>
        <Table
          dataSource={expanded}
          columns={columns}
          pagination={false}
          rowKey={(record, index) => `${rowdata.field}-${index}`}
          bordered
          scroll={{ x: 'max-content' }}
        />
      </Card>
    );
  }

  return (
    <div className="space-y-8">
      {fieldsToCompare.map(field => (
        <React.Fragment key={field}>
          {(() => {
            const tables = [];
            const row = { field };

            fqdnKeys.forEach((fqdn, idx) => {
              const device = filteredDevices[idx];
              const tableRowVal = device?.[field];
              row[fqdn] = resolveValue(tableRowVal);
            });

            // Special case for known multi-item arrays
            const sampleVal = filteredDevices[0]?.[field];
            const isMultiItem = ['profiles', 'irules', 'security_logging_profiles'].includes(field.toLowerCase());

            if (Array.isArray(sampleVal) && isMultiItem) {
              const maxItems = Math.max(...filteredDevices.map(d => (d[field] || []).length));
              for (let i = 0; i < maxItems; i++) {
                const row2 = { field };
                fqdnKeys.forEach((fqdn, idx2) => {
                  const val = filteredDevices[idx2][field]?.[i];
                  row2[fqdn] = resolveValue(val);
                });
                tables.push(df(row2, `Item ${i + 1}`));
              }
            } else {
              tables.push(df(row));
            }

            return tables;
          })()}
        </React.Fragment>
      ))}
    </div>
  );
};

export default TransposedFqdnGrouped;
